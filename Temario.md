Estructuras de Datos
====================

Temario
-------

1. Introducción (*semana 1, sesión 1*)
1. Genéricos (*semana 1, sesión 2*)
    1. Tipos genéricos
    1. Borradura de tipos
    1. Acotamiento de tipos
    1. Empacamiento y desempacamiento
1. Iteradores (*semana 2, sesión 3*)
    1. El operador *for-each*
1. Colecciones (*semana 2, sesión 3*)
1. Listas (*semanas 2-3, sesiones 4-5*)
    1. Definición de listas
    1. Algoritmos para listas
    1. Iteradores para listas
1. Complejidad computacional (*semana 3, sesión 6*)
    1. La notación de *O* grandota
    1. Complejidades en tiempo y en espacio
1. Arreglos (*semana 4, sesión 7*)
    1. El polinomio de redireccionamiento
    1. Arreglos y genéricos
1. Pilas y colas (*semana 4, sesión 8*)
    1. Algoritmos de la clase abstracta
    1. Algoritmos para pilas
    1. Algoritmos para colas
1. Lambdas (*semanas 4-5, sesiones 8-9*)
    1. Lambdas y funciones de primera clase
    1. Clases internas anónimas
    1. Lambdas en Java con interfaces funcionales
1. Ordenamientos (*semanas 5-6, sesiones 9-10*)
    1. Ordenamientos en arreglos
        1. Algoritmo SelectionSort
        1. Algoritmo QuickSort
        1. Manteniendo arreglos ordenados
    1. Ordenamientos en listas
        1. Algoritmo MergeSort
        1. Manteniendo listas ordenadas
    1. La razón para ordenar colecciones
1. Búsquedas (*semana 6, sesión 11*)
    1. Búsquedas en arreglos
    1. Búsquedas en listas
1. Árboles binarios (*semanas 6-7, sesiones 12-13*)
    1. Definición de árboles binarios
    1. Propiedades de árboles binarios
    1. Implementación en Java
    1. Algoritmos para árboles binarios
    1. Aprovechando referencias no utilizadas
1. Árboles binarios completos (*semana 7, sesión 13-14*)
    1. Definición de árboles binarios completos
    1. Recorriendo árboles por amplitud
    1. Acciones para vértices de árboles binarios
    1. Algoritmos para árboles binarios completos
1. Árboles binarios ordenados (*semana 8, sesiones 15-16*)
    1. Definición de árboles binarios ordenados
    1. Recorriendo árboles por profundidad
        1. DFS *pre-order*
        1. DFS *post-order*
        1. DFS *in-order*
    1. Algoritmos para árboles binarios ordenados
    1. Complejidades en tiempo y en espacio
1. Árboles rojinegros (*semanas 9-10, sesiones 17-19*)
    1. Definición de árboles rojinegros
    1. Algoritmos de los árboles rojinegros
        1. Algoritmo para agregrar
        1. Algoritmo para eliminar
1. Árboles AVL (*semana 10, sesión 20*)
    1. Definición de árboles AVL
    1. Algoritmos de los árboles AVL
        1. Algoritmo de rebalanceo
1. Gráficas (*semana 11, sesiones 21-22*)
    1. Definición de gráficas
    1. Propiedades de gráficas
    1. Implementación en Java
    1. Recorridos en gráficas
        1. BFS en gráficas
        1. DFS en gráficas
    1. Algoritmos para gráficas
    1. Implementaciones alternativas de gráficas
1. Montículos mínimos (*semana 12, sesiones 23-24*)
    1. Definición de montículos mínimos
    1. Acomodando hacia arriba y hacia abajo
        1. Acomodando hacia arriba
        1. Acomodando hacia abajo
    1. Implementación en Java
    1. Algoritmos para montículos mínimos
    1. Algoritmo HeapSort
    1. Montículos de arreglos
1. Algoritmo de Dijkstra (*semana 13, sesiones 25-26*)
    1. Definición de trayectoria de peso mínimo
    1. Implementación en Java
    1. Algoritmos para gráficas con pesos en las aristas
    1. Algoritmo de trayectoria mínima
    1. Algoritmo de Dijkstra
    1. Reconstruyendo trayectorias
    1. Pesos con matrices de adyacencias
1. Funciones de dispersión (*semana 14, sesiones 27-28*)
    1. Colisiones en funciones de dispersión
    1. Implementación en Java
        1. Cascando huevos
    1. Función de dispersión XOR
    1. Función de dispersión Bob Jenkins
    1. Función de dispersión de Daniel J. Bernstein
    1. Funciones de dispersión para diccionarios
1. Diccionarios (*semana 15, sesiones 29-30*)
    1. El arreglo del diccionario
    1. Implementación en Java
    1. Algoritmos para diccionarios
    1. Complejidades en tiempo y en espacio
    1. Implementaciones alternas de diccionarios
1. Conjuntos (*semana 16, sesión 31*)
    1. Implementación en Java
    1. Algoritmos para conjuntos
    1. Otros usos de conjuntos
1. Mejorando gráficas (*semana 16, sesión 31*)
    1. Modificaciones al código
1. Conclusiones (*semana 16, sesión 32*)
